# 01 - Course Overview
    1.1 - Course Overview
        Clean Architecture: es un conjunto de practicas utilizadas para crear una arquitectura de software comprensible, flexible comprobable y mantenible.

        Es un reemplazo de la arquitectura tradicional (centrada en base de datos de tres capas) que usamos durante decadas. 

        Vamos a aprender Clean Architecture, que es y que es importante. 
        Después sobre una serie de prácticas arquitectónicas modernas, como:
            - la arquitectura centrada en el dominio
            - las capas de aplicación
            - la separación de responsabilidad por consulta de comandos (CQRS) 
            - la organización funcional 
            - las arquitecturas de microservicios. 
            
        Estas prácticas arquitectónicas hacen que su arquitectura sea más comprobable, más fácil de mantener y permite que la arquitectura evolucione con el tiempo. 
        
# 02 - Introduction
    2.1 - Introduction
        Da un ejemplo sobre dos diferentes tipos de arquitectos (de edificios), para dar una introducción al tema...

    2.2 - Overview
        Resumen del curso... 
        
        1) Se discute sobre arquitectura limpia, qué es y por qué es importante. 
        2) Arquitecturas centradas en el dominio y por qué podríamos querer colocar nuestro modelo de dominio en el         centro de nuestra arquitectura. 
        3) Capa de aplicación y por qué podríamos querer incorporar los casos de uso de nuestro sistema en una capa de      aplicación. 
        4) Analizaremos la separación de responsabilidad de consulta de comando (CQRS), y por qué podríamos querer          separar las pilas de comandos y consultas de nuestra arquitectura. 
        5) Práctica de la arquitectura de gritos?? y cómo puede ayudarnos a organizar nuestra estructura de carpetas y      espacios de nombres usando la cohesión funcional. 
        6) Microservicios y cómo podríamos querer dividir horizontalmente nuestra aplicación por contextos limitados. 7) Prácticas de arquitectura comprobables y cómo nuestra arquitectura hace que las pruebas sean más fáciles,        no más difíciles
        8) Cómo podemos evolucionar nuestra arquitectura para reducir los riesgos debido a la incertidumbre en los          requisitos cambiantes durante la vida del proyecto. 
        
        Además, en cada módulo de este curso veremos código de muestra de una aplicación creada utilizando estos diversos patrones, prácticas y principios. 
        
        Debido a que es un tema tan amplio como la arquitectura de software puede descontrolarse muy rápido, tendremos que mantener este curso limitado de varias maneras clave. 
        
            1) Nos centraremos en la arquitectura para crear aplicaciones empresariales. Es decir, aplicaciones             diseñadas para resolver problemas de negocios
            2) Las prácticas arquitectónicas en las que nos centraremos están diseñadas para soportar un proceso de         desarrollo de software ágil. 
            3)  Nos centraremos en las siete ideas principales que me han ayudado limpiar mi arquitectura más. 
            
            * Si estas interesado en profundizar mucho más, lo guiaré en la dirección de fuentes de información adicionales al final del último módulo de este curso. 

    2.3 - What Is Clean Code?
        
        Qué es la arquitectura de software:
            Si bien no es facil de definir, hay conceptos generales en los que estar de acuerdo.
                1) Es de alto nivel.
                2) Tiene que ver con la estructura del software o cómo se organizan las cosas. 
                3) Típicamente involucra capas, que son particiones verticales del sistema. 
                4) Generalmente involucra componentes de algún tipo, que son típicamente particiones horizontales           dentro de cada capa. 
                5) Involucra las relaciones entre estas cosas, así es como todas están conectadas entre sí. 
            
            Cuando hablamos de arquitectura, podemos centrarnos en uno de los muchos niveles de abstracción. 
            
            SISTEMA                  En la parte superior: el sistema (representación más abstracta del software) 
              SUB-SUBSISTEMAS        -> que se puede representar como un conjunto de uno o más subsistemas 
                CAPAS                -> que generalmente se dividen en una o más capas, 
                  COMPONENTES        -> que a menudo se subdividen en una o más componentes, 
                    CLASES Y METODOS -> que contienen clases que contienen datos y métodos. 
            
            Creo que todos tenemos una intuición general sobre cómo se ve la arquitectura desordenada versus cómo se ve la arquitectura limpia. 
                
                Espaguettis:
                    - Desordenada, es dificil de agregar cosas, un pequeño cambio/reemplazo rompe todo. 
                vs 
                Lasagna:
                    - Tiene lindos, consistentes, límites que dividen uniformemente las diversas capas.
                    - Cuando una pieza es demasiado grande, la cortamos en componentes más pequeños
                    - Tiene una bonita capa de presentación montada sobre una pila comestible de funcionalidad. 
                    
            Entonces, en términos más técnicos: 
            
                ¿qué es la arquitectura mala o desordenada? 
                    - Compleja
                    - Es incoherente (las partes no parecen encajar).
                    - Rígido, es decir, la arquitectura resiste el cambio o dificulta la evolución de la arquitectura con el tiempo. 
                    - Frágil, tocar una parte del código aquí podría romper otra parte del código en otro lugar
                    - No es comprobable, es decir, realmente te gustaría escribir pruebas unitarias y pruebas de integración, pero la arquitectura te combate en cada paso del camino y, en última instancia, todas estas cosas conducen a una arquitectura que no se puede mantener durante la vida del proyecto. 
                
                Arquitectura buena y limpia:
                    - Simple o al menos es tan compleja como es necesaria.
                    - Comprensible, es fácil razonar sobre el software en su conjunto
                    - Es flexible, podemos adaptar fácilmente el sistema para cumplir con los requisitos cambiantes
                    - Emergente, la arquitectura evoluciona a lo largo de la vida del proyecto.
                    - Comprobable, la arquitectura hace pruebas más fácil, no más difícil
                    - Sostenible durante la vida del proyecto.
                
                HABITANTES (ok) - ARQUITECTOS (x) - MAQUINA (x)

                La forma en que resumí la arquitectura limpia es que es una arquitectura diseñada para los habitantes de la arquitectura.
                
                La arquitectura limpia se trata de enfocarse en lo que es realmente esencial para la arquitectura del software versus lo que es solo un detalle de implementación. Al diseñar para los HABITANTES nos referimos a las personas que vivirán dentro de la arquitectura durante la vida del proyecto. Esto significa que los usuarios del sistema, los desarrolladores que crean el sistema y los desarrolladores que mantienen el sistema. 
                
                Al no diseñar para el ARQUITECTO, queremos decir que el arquitecto debe dejar de lado sus propios deseos, preferencias y deseos, y solo considerar lo que es mejor para los habitantes de la arquitectura con cada decisión que se tome. 
                
                Al no diseñar para la MÁQUINA, queremos decir que primero debemos optimizar la arquitectura para las necesidades de los habitantes, es decir, los usuarios y los desarrolladores, y solo optimizar para la máquina cuando el costo del rendimiento les afecta a los usuarios, que son habitantes de La arquitectura, supera el beneficio de un diseño limpio para los desarrolladores que también son habitantes de la arquitectura. 
                
                Esencialmente, queremos evitar La optimización prematura, que es la raíz de todo mal en el desarrollo de software.
                
                * Necesitamos diseñar nuestra arquitectura primero para los habitantes de la arquitectura, todo lo demás, nuestros egos, nuevos marcos brillantes, optimizaciones de rendimiento, etc., deberían ser una preocupación secundaria. *

    2.4 - Why Invest in Clean Code?
        
        La justificación principal para invertir en arquitectura limpia es principalmente un argumento de costo beneficio. 
        
        Nuestro objetivo como arquitectos de software es:
             minimizar el costo de crear y mantener el software mientras maximizamos el beneficio que es el valor comercial que proporciona el software. 
        
        Nuestro objetivo general es:
            Maximizar el retorno de la inversión, que es el ROI del proyecto de software en su conjunto. 
            
         1) La arquitectura limpia se enfoca en las necesidades esenciales de los habitantes primarios del sistema;         Esos son los usuarios. Intentamos construir un sistema que refleje los casos de uso y los modelos               mentales de los usuarios al incorporar estos casos de uso y modelos mentales tanto en nuestra                   arquitectura como en nuestro código. 
         
         2) La arquitectura limpia construye solo lo que es necesario cuando es necesario. Intentamos crear solo las        características y la arquitectura correspondiente que son necesarias para resolver las necesidades            inmediatas de los usuarios en orden de valor comercial percibido por cada característica. Intentamos          hacer esto sin crear ninguna complejidad accidental, características innecesarias, optimizaciones de          rendimiento prematuras o adornos arquitectónicos. Esto ayuda a reducir el costo de crear el                   sistema. 
         
         3) La arquitectura limpia se optimiza para la mantenibilidad. Para una aplicación empresarial promedio con un      ciclo de vida suficientemente largo, digamos unos 10 años, gastamos significativamente más tiempo y           dinero en mantener el sistema que en crearlo. Varias fuentes que he visto indican que aproximadamente         del 60 al 80% del costo de la vida útil de la aplicación de software proviene del mantenimiento, por lo       que si optimizamos la capacidad de mantenimiento, lo que hace una arquitectura limpia, en teoría              reduciremos el costo de mantenimiento del sistema . 
         
         Este enfoque en actividades de valor agregado y reducción de costos intenta maximizar el retorno de la inversión del software en su conjunto. 
         
         El objetivo final de un arquitecto es tomar decisiones que intercambien cosas como la complejidad, de tal manera que minimice el costo y maximice el valor comercial, maximizando así el retorno de la inversión del proyecto de software en su conjunto.          

    2.5 - Demo
        Muestra una app sencilla de ventas con diferentes menus que traen dif info, los proyectos que tiene la solución:

        Resuemen de la tecnologia que usó:
        - VisualStudio. NET 2015. 
        - Todo el código fue creado con C # usando el. NET framework, 4. 5. 
        - La aplicación usa ASP. NET MVC 5 con sintaxis Razor para las vistas. 
        - La base de datos es Microsoft SQL Server 2014. 
        - La aplicación utiliza Entity Framework 6 como ORM, es decir, Object Relational Mapper, para asignar objetos   a entidades dentro de la base de datos. 
        - StructureMap 3.1 -> Usamos el mapa de estructura tres como un marco de inyección de dependencias para conectar todas nuestras dependencias juntas en tiempo de ejecución
        - Usamos NUnit para pruebas unitarias, Moq para un marco de prueba de prueba
        - AutoMoq para facilitar las pruebas unitarias y de burla,
        - SpecFlow para un diseño basado en el comportamiento Pruebas de aceptación basadas. Sin embargo, puede utilizar cualquier herramienta, tecnología y marco que le gustaría implementar su propia arquitectura limpia. 
        - SQL Server 2014, se puede usar también SQL Express.

        Proyectos:
            1) Presentación. Comenzando con la parte superior conceptual de la aplicación. Este proyecto                    contiene la interfaz de usuario en la aplicación. 
            2) Solicitud; Este proyecto contiene abstracciones correspondientes a los casos de uso de la aplicación. 
            3) Dominio; Este proyecto contiene abstracciones correspondientes al dominio del problema, que es el            dominio empresarial. 
            4) Persistencia; Este proyecto proporciona una interfaz en el medio de almacenamiento persistente, que es la base de datos. 
            5) Infraestructura; Este proyecto contiene una interfaz en el sistema operativo y dependencias de terceros. 
            6) Común; Este proyecto contiene preocupaciones transversales, es decir, aspectos de la aplicación de los que dependen todos los proyectos y especificaciones. 
            7) Este proyecto contiene pruebas de aceptación que verifican la funcionalidad correcta de la aplicación. 
            
            Base de datos Microsoft SQL Server 2014; sin embargo, la aplicación de demostración también funcionará con SQL Express, la versión gratuita de Microsoft de SQL Server, si lo prefiere. 
            
           
           Ejercicios: https://app.pluralsight.com/library/courses/clean-architecture-patterns-practices-principles/exercise-files
           
           Repo de él: https://github.com/matthewrenze/clean-architecture-demo

    2.6 Summary
        En este módulo, primero vimos una descripción general del curso, cubrimos el propósito del curso, su enfoque y la audiencia prevista. Luego, aprendimos acerca de la arquitectura limpia, qué es, por qué es importante y cómo el contexto es crítico con cada decisión arquitectónica que tomamos. Luego vimos una demostración en la que presentamos la aplicación que usaremos para todas las demostraciones en este curso. Vimos la interfaz de usuario, las tecnologías, los archivos del proyecto y la base de datos. En el próximo módulo aprenderemos sobre arquitecturas centradas en el dominio.

# Domain-centric Architecture
    Introduction
        Introducción
            Módulo aprenderemos sobre la arquitectura centrada en el dominio. 
            
            Primero aprenderemos sobre la arquitectura centrada en el dominio y cómo difiere de la arquitectura centrada en la base de datos. A continuación, aprenderemos sobre tres tipos de arquitecturas centradas en el dominio. Luego, aprenderemos sobre los pros y los contras de implementar una arquitectura centrada en el dominio. Finalmente, veremos una demostración de nuestra aplicación de demostración centrada en el dominio, así que comencemos.

    Domain-centric Architecture
        Todos sabemos que la tierra está en el centro del sistema solar, y que el sol, la luna y los planetas giran alrededor de la tierra. ¿Correcto? Bueno, ya no lo hacen, pero lo hicieron al mismo tiempo. Sin embargo, un tipo muy inteligente llamado Nicolaus Copernicus cambió la forma en que vemos nuestro sistema solar. En lugar de suponer que la Tierra estaba en el centro del sistema solar, el viejo Nick tuvo la loca idea de que el sol podría estar en el centro de nuestro sistema solar. Este cambio de perspectiva resultó para producir un mejor modelo del sistema solar, en el sentido de que es más simple y, sin embargo, proporciona más poder explicativo. 
        
        Un cambio similar en el pensamiento está ocurriendo en el mundo de la arquitectura de software mientras hablamos. 
        la clásica arquitectura centrada en la base de datos de tres capas:
             Su característica clave es que la interfaz de usuario, la lógica empresarial y la capa de acceso a datos giran en torno a la base de datos. 
             La base de datos es esencial y, por lo tanto, está en el centro de esta arquitectura. 
             
        Sin embargo, una nueva perspectiva ha cambiado la forma en que muchos de nosotros vemos nuestra arquitectura. En lugar de tener la base de datos en el centro de nuestra arquitectura, algunos de nosotros estamos poniendo el dominio en el centro y haciendo que la base de datos sea solo un detalle de implementación fuera de la arquitectura. Aquí el dominio es esencial, y la base de datos es solo un detalle. 
        
        Entonces, ¿por qué ha sucedido esto? Creo que este cambio de perspectiva se resume mejor en una cita de Robert C. Martin, más conocido en la industria del software como Tío Bob. 
        
        Él dice, "la primera preocupación del arquitecto es asegurarse de que la casa sea utilizable,no es asegurarse de que la casa esté hecha de ladrillo". Este cambio en la perspectiva arquitectónica está siendo causado por un cambio en la perspectiva sobre lo que es esencial en una arquitectura versus lo que es solo un detalle de implementación. 
        
        Usando nuestra metáfora de la arquitectura del edificio, cuando estamos construyendo una casa, ¿qué es esencial versus qué es un detalle? El espacio dentro de una casa es esencial. Sin un espacio vacío para habitar la casa no serviría de nada. La usabilidad de la casa es esencial. Si la casa no contuviera habitaciones y características para satisfacer nuestras necesidades primarias, nuevamente, la casa no cumpliría su propósito. 
        
        Sin embargo, el material de construcción es solo un detalle de implementación. Podríamos construirlo de ladrillo, piedra, madera o muchos otros materiales. 
        
        Además, la ornamentación es solo un detalle. Todavía podríamos vivir en esta casa si tenía molduras victorianas, adornos dorados, puertas francesas o ninguna ornamentación. Las cosas que son esenciales en una casa son así porque satisfacen las necesidades primarias de los habitantes de la casa. Todo lo demás es solo un detalle de implementación. En arquitectura limpia, lo mismo es cierto. Lo esencial son las cosas que apoyan las necesidades primarias de los habitantes de la arquitectura. El modelo de dominio es esencial. Sin él, el sistema no representaría los modelos mentales de los usuarios. 
        
        Los casos de uso son esenciales. Sin ellos, el sistema no resolvería los problemas del usuario. 
        
        Sin embargo, la presentación es solo un detalle. Podemos entregar la IU en formularios web, ASP. NET MVC o como una aplicación de JavaScript de una sola página, y la persistencia es solo un detalle. 
        
        Podemos almacenar los datos en una base de datos relacional, no en una base de datos SQL o como archivos JSON antiguos. Ahora no me malinterpreten, las tecnologías de presentación y persistencia son muy importantes. Simplemente no son esenciales para resolver el problema que el usuario intenta resolver con la aplicación. 
        
        Una vez que hemos cambiado nuestra perspectiva sobre lo que es esencial frente a lo que es un detalle en la arquitectura de software, podemos comenzar a ver por qué está ocurriendo una transición de la arquitectura centrada en la base de datos a la arquitectura centrada en el dominio. 
        
        Con las arquitecturas centradas en la base de datos, la base de datos es esencial, por lo que la base de datos está en el centro de la aplicación y todas las dependencias apuntan hacia la base de datos. Con las arquitecturas centradas en el dominio, el dominio y los casos de uso son esenciales, y la presentación y la persistencia son solo un detalle, por lo que el dominio está en el centro de la aplicación envuelto en una capa de aplicación y todas las dependencias apuntan hacia el dominio. 
        
        Así que ahora echemos un vistazo a algunos tipos de arquitecturas centradas en el dominio. 
            Primero, tenemos la arquitectura hexagonal de Alistair Cockburn. Es una arquitectura en capas con la capa de aplicación y, por lo tanto, transitivamente, el dominio en el centro de la arquitectura. Además, es una arquitectura de complemento que incluye puertos y adaptadores. Esencialmente, las capas externas de la arquitectura están adaptando la capa de aplicación interna a los diversos medios de presentación, medios de persistencia y sistemas externos. Puede ejecutar, y por lo tanto probar, un aislamiento en toda esta arquitectura de aplicación sin una interfaz de usuario, una base de datos o dependencias externas. 
            
            A continuación, con la arquitectura de cebolla de Jeffrey Palermo. Esta también es una arquitectura en capas con el dominio en el centro rodeado por una capa de aplicación. La capa exterior

    Demo
    Summary

# Application Layer
    Introduction
    Application Layer
    Demo
    Summary

# Commands and Queries
    Introduction
    Commands and Queries
    Demo
    Summary

# Functional Organization
    Introduction
    Functional Organization
    Demo
    Summary

# Microservices
    Introduction
    Microservices
    Demo
    Summary

# Testable Architecture
    Introduction
    Testable Architecture
    Demo
    Summary

# Evolving the Architecture
    Introduction
    Evolving the Architecture
    Where to Go Next
    Course Summary