# 01 - Course Overview
    1.1 - Course Overview
        Clean Architecture: es un conjunto de practicas utilizadas para crear una arquitectura de software comprensible, flexible comprobable y mantenible.

        Es un reemplazo de la arquitectura tradicional (centrada en base de datos de tres capas) que usamos durante decadas. 

        Vamos a aprender Clean Architecture, que es y que es importante. 
        Después sobre una serie de prácticas arquitectónicas modernas, como:
            - la arquitectura centrada en el dominio
            - las capas de aplicación
            - la separación de responsabilidad por consulta de comandos (CQRS) 
            - la organización funcional 
            - las arquitecturas de microservicios. 
            
        Estas prácticas arquitectónicas hacen que su arquitectura sea más comprobable, más fácil de mantener y permite que la arquitectura evolucione con el tiempo. 
        
# 02 - Introduction
    2.1 - Introduction
        Da un ejemplo sobre dos diferentes tipos de arquitectos (de edificios), para dar una introducción al tema...

    2.2 - Overview
        Resumen del curso... 
        
        1) Se discute sobre arquitectura limpia, qué es y por qué es importante. 
        2) Arquitecturas centradas en el dominio y por qué podríamos querer colocar nuestro modelo de dominio en el         centro de nuestra arquitectura. 
        3) Capa de aplicación y por qué podríamos querer incorporar los casos de uso de nuestro sistema en una capa de      aplicación. 
        4) Analizaremos la separación de responsabilidad de consulta de comando (CQRS), y por qué podríamos querer          separar las pilas de comandos y consultas de nuestra arquitectura. 
        5) Práctica de la arquitectura de gritos?? y cómo puede ayudarnos a organizar nuestra estructura de carpetas y      espacios de nombres usando la cohesión funcional. 
        6) Microservicios y cómo podríamos querer dividir horizontalmente nuestra aplicación por contextos limitados. 7) Prácticas de arquitectura comprobables y cómo nuestra arquitectura hace que las pruebas sean más fáciles,        no más difíciles
        8) Cómo podemos evolucionar nuestra arquitectura para reducir los riesgos debido a la incertidumbre en los          requisitos cambiantes durante la vida del proyecto. 
        
        Además, en cada módulo de este curso veremos código de muestra de una aplicación creada utilizando estos diversos patrones, prácticas y principios. 
        
        Debido a que es un tema tan amplio como la arquitectura de software puede descontrolarse muy rápido, tendremos que mantener este curso limitado de varias maneras clave. 
        
            1) Nos centraremos en la arquitectura para crear aplicaciones empresariales. Es decir, aplicaciones             diseñadas para resolver problemas de negocios
            2) Las prácticas arquitectónicas en las que nos centraremos están diseñadas para soportar un proceso de         desarrollo de software ágil. 
            3)  Nos centraremos en las siete ideas principales que me han ayudado limpiar mi arquitectura más. 
            
            * Si estas interesado en profundizar mucho más, lo guiaré en la dirección de fuentes de información adicionales al final del último módulo de este curso. 

    2.3 - What Is Clean Code?
        
        Qué es la arquitectura de software:
            Si bien no es facil de definir, hay conceptos generales en los que estar de acuerdo.
                1) Es de alto nivel.
                2) Tiene que ver con la estructura del software o cómo se organizan las cosas. 
                3) Típicamente involucra capas, que son particiones verticales del sistema. 
                4) Generalmente involucra componentes de algún tipo, que son típicamente particiones horizontales           dentro de cada capa. 
                5) Involucra las relaciones entre estas cosas, así es como todas están conectadas entre sí. 
            
            Cuando hablamos de arquitectura, podemos centrarnos en uno de los muchos niveles de abstracción. 
            
            SISTEMA                  En la parte superior: el sistema (representación más abstracta del software) 
              SUB-SUBSISTEMAS        -> que se puede representar como un conjunto de uno o más subsistemas 
                CAPAS                -> que generalmente se dividen en una o más capas, 
                  COMPONENTES        -> que a menudo se subdividen en una o más componentes, 
                    CLASES Y METODOS -> que contienen clases que contienen datos y métodos. 
            
            Creo que todos tenemos una intuición general sobre cómo se ve la arquitectura desordenada versus cómo se ve la arquitectura limpia. 
                
                Espaguettis:
                    - Desordenada, es dificil de agregar cosas, un pequeño cambio/reemplazo rompe todo. 
                vs 
                Lasagna:
                    - Tiene lindos, consistentes, límites que dividen uniformemente las diversas capas.
                    - Cuando una pieza es demasiado grande, la cortamos en componentes más pequeños
                    - Tiene una bonita capa de presentación montada sobre una pila comestible de funcionalidad. 
                    
            Entonces, en términos más técnicos: 
            
                ¿qué es la arquitectura mala o desordenada? 
                    - Compleja
                    - Es incoherente (las partes no parecen encajar).
                    - Rígido, es decir, la arquitectura resiste el cambio o dificulta la evolución de la arquitectura con el tiempo. 
                    - Frágil, tocar una parte del código aquí podría romper otra parte del código en otro lugar
                    - No es comprobable, es decir, realmente te gustaría escribir pruebas unitarias y pruebas de integración, pero la arquitectura te combate en cada paso del camino y, en última instancia, todas estas cosas conducen a una arquitectura que no se puede mantener durante la vida del proyecto. 
                
                Arquitectura buena y limpia:
                    - Simple o al menos es tan compleja como es necesaria.
                    - Comprensible, es fácil razonar sobre el software en su conjunto
                    - Es flexible, podemos adaptar fácilmente el sistema para cumplir con los requisitos cambiantes
                    - Emergente, la arquitectura evoluciona a lo largo de la vida del proyecto.
                    - Comprobable, la arquitectura hace pruebas más fácil, no más difícil
                    - Sostenible durante la vida del proyecto.
                
                HABITANTES (ok) - ARQUITECTOS (x) - MAQUINA (x)

                La forma en que resumí la arquitectura limpia es que es una arquitectura diseñada para los habitantes de la arquitectura.
                
                La arquitectura limpia se trata de enfocarse en lo que es realmente esencial para la arquitectura del software versus lo que es solo un detalle de implementación. Al diseñar para los HABITANTES nos referimos a las personas que vivirán dentro de la arquitectura durante la vida del proyecto. Esto significa que los usuarios del sistema, los desarrolladores que crean el sistema y los desarrolladores que mantienen el sistema. 
                
                Al no diseñar para el ARQUITECTO, queremos decir que el arquitecto debe dejar de lado sus propios deseos, preferencias y deseos, y solo considerar lo que es mejor para los habitantes de la arquitectura con cada decisión que se tome. 
                
                Al no diseñar para la MÁQUINA, queremos decir que primero debemos optimizar la arquitectura para las necesidades de los habitantes, es decir, los usuarios y los desarrolladores, y solo optimizar para la máquina cuando el costo del rendimiento les afecta a los usuarios, que son habitantes de La arquitectura, supera el beneficio de un diseño limpio para los desarrolladores que también son habitantes de la arquitectura. 
                
                Esencialmente, queremos evitar La optimización prematura, que es la raíz de todo mal en el desarrollo de software.
                
                * Necesitamos diseñar nuestra arquitectura primero para los habitantes de la arquitectura, todo lo demás, nuestros egos, nuevos marcos brillantes, optimizaciones de rendimiento, etc., deberían ser una preocupación secundaria. *

    2.4 - Why Invest in Clean Code?
        
        La justificación principal para invertir en arquitectura limpia es principalmente un argumento de costo beneficio. 
        
        Nuestro objetivo como arquitectos de software es:
             minimizar el costo de crear y mantener el software mientras maximizamos el beneficio que es el valor comercial que proporciona el software. 
        
        Nuestro objetivo general es:
            Maximizar el retorno de la inversión, que es el ROI del proyecto de software en su conjunto. 
            
         1) La arquitectura limpia se enfoca en las necesidades esenciales de los habitantes primarios del sistema;         Esos son los usuarios. Intentamos construir un sistema que refleje los casos de uso y los modelos               mentales de los usuarios al incorporar estos casos de uso y modelos mentales tanto en nuestra                   arquitectura como en nuestro código. 
         
         2) La arquitectura limpia construye solo lo que es necesario cuando es necesario. Intentamos crear solo las        características y la arquitectura correspondiente que son necesarias para resolver las necesidades            inmediatas de los usuarios en orden de valor comercial percibido por cada característica. Intentamos          hacer esto sin crear ninguna complejidad accidental, características innecesarias, optimizaciones de          rendimiento prematuras o adornos arquitectónicos. Esto ayuda a reducir el costo de crear el                   sistema. 
         
         3) La arquitectura limpia se optimiza para la mantenibilidad. Para una aplicación empresarial promedio con un      ciclo de vida suficientemente largo, digamos unos 10 años, gastamos significativamente más tiempo y           dinero en mantener el sistema que en crearlo. Varias fuentes que he visto indican que aproximadamente         del 60 al 80% del costo de la vida útil de la aplicación de software proviene del mantenimiento, por lo       que si optimizamos la capacidad de mantenimiento, lo que hace una arquitectura limpia, en teoría              reduciremos el costo de mantenimiento del sistema . 
         
         Este enfoque en actividades de valor agregado y reducción de costos intenta maximizar el retorno de la inversión del software en su conjunto. 
         
         El objetivo final de un arquitecto es tomar decisiones que intercambien cosas como la complejidad, de tal manera que minimice el costo y maximice el valor comercial, maximizando así el retorno de la inversión del proyecto de software en su conjunto.          

    2.5 - Demo
        Muestra una app sencilla de ventas con diferentes menus que traen dif info, los proyectos que tiene la solución:

        Resuemen de la tecnologia que usó:
        - VisualStudio. NET 2015. 
        - Todo el código fue creado con C # usando el. NET framework, 4. 5. 
        - La aplicación usa ASP. NET MVC 5 con sintaxis Razor para las vistas. 
        - La base de datos es Microsoft SQL Server 2014. 
        - La aplicación utiliza Entity Framework 6 como ORM, es decir, Object Relational Mapper, para asignar objetos   a entidades dentro de la base de datos. 
        - StructureMap 3.1 -> Usamos el mapa de estructura tres como un marco de inyección de dependencias para conectar todas nuestras dependencias juntas en tiempo de ejecución
        - Usamos NUnit para pruebas unitarias, Moq para un marco de prueba de prueba
        - AutoMoq para facilitar las pruebas unitarias y de burla,
        - SpecFlow para un diseño basado en el comportamiento Pruebas de aceptación basadas. Sin embargo, puede utilizar cualquier herramienta, tecnología y marco que le gustaría implementar su propia arquitectura limpia. 
        - SQL Server 2014, se puede usar también SQL Express.

        Proyectos:
            1) Presentación. Comenzando con la parte superior conceptual de la aplicación. Este proyecto                    contiene la interfaz de usuario en la aplicación. 
            2) Solicitud; Este proyecto contiene abstracciones correspondientes a los casos de uso de la aplicación. 
            3) Dominio; Este proyecto contiene abstracciones correspondientes al dominio del problema, que es el            dominio empresarial. 
            4) Persistencia; Este proyecto proporciona una interfaz en el medio de almacenamiento persistente, que es la base de datos. 
            5) Infraestructura; Este proyecto contiene una interfaz en el sistema operativo y dependencias de terceros. 
            6) Común; Este proyecto contiene preocupaciones transversales, es decir, aspectos de la aplicación de los que dependen todos los proyectos y especificaciones. 
            7) Este proyecto contiene pruebas de aceptación que verifican la funcionalidad correcta de la aplicación. 
            
            Base de datos Microsoft SQL Server 2014; sin embargo, la aplicación de demostración también funcionará con SQL Express, la versión gratuita de Microsoft de SQL Server, si lo prefiere. 
            
           
           Ejercicios: https://app.pluralsight.com/library/courses/clean-architecture-patterns-practices-principles/exercise-files
           
           Repo de él: https://github.com/matthewrenze/clean-architecture-demo

    2.6 Summary
        En este módulo, primero vimos una descripción general del curso, cubrimos el propósito del curso, su enfoque y la audiencia prevista. Luego, aprendimos acerca de la arquitectura limpia, qué es, por qué es importante y cómo el contexto es crítico con cada decisión arquitectónica que tomamos. Luego vimos una demostración en la que presentamos la aplicación que usaremos para todas las demostraciones en este curso. Vimos la interfaz de usuario, las tecnologías, los archivos del proyecto y la base de datos. En el próximo módulo aprenderemos sobre arquitecturas centradas en el dominio.

# Domain-centric Architecture
    Introduction
    Domain-centric Architecture
    Demo
    Summary

# Application Layer
    Introduction
    Application Layer
    Demo
    Summary

# Commands and Queries
    Introduction
    Commands and Queries
    Demo
    Summary

# Functional Organization
    Introduction
    Functional Organization
    Demo
    Summary

# Microservices
    Introduction
    Microservices
    Demo
    Summary

# Testable Architecture
    Introduction
    Testable Architecture
    Demo
    Summary

# Evolving the Architecture
    Introduction
    Evolving the Architecture
    Where to Go Next
    Course Summary